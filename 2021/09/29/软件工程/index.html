<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>软件工程 | 一位可可爱爱的编橙爱好者</title><meta name="keywords" content="软件工程"><meta name="author" content="Lu sir,2914475618@qq.com"><meta name="copyright" content="Lu sir"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="软件工程声明：该笔记内容来自清华大学软件工程软件工程 - 清华大学 - 学堂在线 (xuetangx.com) 软件工程概述1.定义 软件是软件工程的研究对象，也是软件工程的产品形态与客观存在 工程是将理论和知识应用于实践的科学，其目的是经济有效的解决实际问题 软件致力解决如何以经济有效的方法开发高质量软件 包含软件和工程  2.本质特征 复杂性 一致性 可变性-》造成软件开发困难的原因 不可见性">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程">
<meta property="og:url" content="https://a2914475618.github.io/2021/09/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/index.html">
<meta property="og:site_name" content="一位可可爱爱的编橙爱好者">
<meta property="og:description" content="软件工程声明：该笔记内容来自清华大学软件工程软件工程 - 清华大学 - 学堂在线 (xuetangx.com) 软件工程概述1.定义 软件是软件工程的研究对象，也是软件工程的产品形态与客观存在 工程是将理论和知识应用于实践的科学，其目的是经济有效的解决实际问题 软件致力解决如何以经济有效的方法开发高质量软件 包含软件和工程  2.本质特征 复杂性 一致性 可变性-》造成软件开发困难的原因 不可见性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/v2-987f388663dab9d9c63105c2d82645e0_720w.jpg">
<meta property="article:published_time" content="2021-09-29T10:46:09.000Z">
<meta property="article:modified_time" content="2021-12-24T08:02:10.157Z">
<meta property="article:author" content="Lu sir">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/v2-987f388663dab9d9c63105c2d82645e0_720w.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://a2914475618.github.io/2021/09/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-24 16:02:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="css/footer.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="一位可可爱爱的编橙爱好者" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/Touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/v2-987f388663dab9d9c63105c2d82645e0_720w.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">一位可可爱爱的编橙爱好者</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件工程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-29T10:46:09.000Z" title="发表于 2021-09-29 18:46:09">2021-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-24T08:02:10.157Z" title="更新于 2021-12-24 16:02:10">2021-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">知识积累</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件工程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><p>声明：该笔记内容来自清华大学软件工程<a target="_blank" rel="noopener" href="https://www.xuetangx.com/course/THU08091000367/7754180?channel=i.area.recent_search">软件工程 - 清华大学 - 学堂在线 (xuetangx.com)</a></p>
<h2 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul>
<li>软件是软件工程的研究对象，也是软件工程的产品形态与客观存在</li>
<li>工程是将理论和知识应用于实践的科学，其目的是经济有效的解决实际问题</li>
<li>软件致力解决如何以经济有效的方法开发高质量软件</li>
<li>包含软件和工程</li>
</ul>
<h3 id="2-本质特征"><a href="#2-本质特征" class="headerlink" title="2.本质特征"></a>2.本质特征</h3><ul>
<li>复杂性</li>
<li>一致性</li>
<li>可变性-》造成软件开发困难的原因</li>
<li>不可见性</li>
</ul>
<h3 id="3-面临的挑战"><a href="#3-面临的挑战" class="headerlink" title="3.面临的挑战"></a>3.面临的挑战</h3><ol>
<li>客户不满意</li>
<li>项目过程失控</li>
<li>风险与成本问题</li>
<li>无力管理团队</li>
</ol>
<blockquote>
<p>软件 能独立存在，需要依附于 定的环境（如硬件、网络以及其他软件）</p>
<p> 用户层次： 系列实现各种功能的图形化界面</p>
<p>计算机层次：软件 = 程序 + 数据 + 文档</p>
<p> 程序：计算机 以接受的 系列指令，运行时 以提供所要求的的功能和性能</p>
<p> 数据：使得程序能够适当地操作信息的数据结构</p>
<p> 文档：描述程序的研制过程、方法和使用的图文资料</p>
</blockquote>
<h3 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4.基本概念"></a>4.基本概念</h3><p>将系统性的、规范化的、 定量的方法应用于软件的开发、运行和维护，即工程化应用到软件商</p>
<h3 id="5-基本要素"><a href="#5-基本要素" class="headerlink" title="5.基本要素"></a>5.基本要素</h3><ol>
<li><p>过程</p>
<p> 一系列开发活动，将客户需求转化成客户满意的产品</p>
<ol>
<li>问题定义</li>
<li>需求开发</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
</ol>
</li>
<li><p>方法</p>
<ol>
<li>面向过程：以算法作为基本构造单元，强调自顶向下的功能分解，将功能和数据进行一定程度的分离</li>
<li>面向对象：以类为基本程序单元，对象是类的实例化，对象之间以消息传递为基本手段</li>
<li>面向构件：寻求比类的粒度更大的且易于 用的构件，期望实现软件的再工程</li>
<li>面向服务：在应用表现层次上将软件构件化，即应用业务过程由服务组 ，而服务由构件组装而 </li>
</ol>
</li>
<li><p>工具</p>
<ol>
<li>软件构造工具</li>
<li>软件测试工具</li>
<li>软件工程管理工具</li>
<li>软件维护工具</li>
<li>软件建模工具</li>
</ol>
</li>
</ol>
<h3 id="6-软件开发基本策略"><a href="#6-软件开发基本策略" class="headerlink" title="6.软件开发基本策略"></a>6.软件开发基本策略</h3><ol>
<li><p>软件复用</p>
<p>构造一个新的系统 必从零做起，直接复用已有的构件进行组装。</p>
</li>
<li><p>分而治之</p>
<p>将一个大的问题分解成若干个简单的问题，然后逐个解决</p>
</li>
<li><p>逐步演进</p>
<p>软件开发是自底向上逐步有序的生长过程</p>
</li>
<li><p>优化折中</p>
</li>
</ol>
<h2 id="软件开发过程"><a href="#软件开发过程" class="headerlink" title="软件开发过程"></a>软件开发过程</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="过程方法"><a href="#过程方法" class="headerlink" title="过程方法"></a>过程方法</h4><blockquote>
<p>过程方法是系统地识别和管理组织内所使用的过程，保证更有效地获得期望的结果</p>
</blockquote>
<h4 id="软件过程分类"><a href="#软件过程分类" class="headerlink" title="软件过程分类"></a>软件过程分类</h4><ol>
<li><p>管理过程</p>
<p>衡量和评价实现过程和 过程的效能建立起组织的质量管理体系</p>
</li>
<li><p>实现过程</p>
<p>提供有价值的产品或服务的关键性活动</p>
</li>
<li><p>支持过程</p>
</li>
</ol>
<h4 id="软件开发过程-1"><a href="#软件开发过程-1" class="headerlink" title="软件开发过程"></a>软件开发过程</h4><ol>
<li>问题提出</li>
<li>可行性研究</li>
<li>可行性分析报告</li>
<li>需求开发</li>
<li>软件设计</li>
<li>软件构造</li>
<li>软件测试</li>
<li>软件维护</li>
<li>软件项目管理</li>
<li>软件配置管理</li>
</ol>
<h3 id="2-软件过程模型"><a href="#2-软件过程模型" class="headerlink" title="2.软件过程模型"></a>2.软件过程模型</h3><blockquote>
<p>软件过程模型是对软件过程的抽象描述</p>
</blockquote>
<h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>将基本的开发活动看做是一系列界限分明的独立阶段，这是一种计划驱动的软件过程，有利于规范软件开发活动</p>
<h4 id="原始化模型"><a href="#原始化模型" class="headerlink" title="原始化模型"></a>原始化模型</h4><p>原型是 一个部分开发的产品，用于加强对系统地理解，有助于明确需求和选择可行的设计策略。</p>
<h4 id="迭代化开发（增量）"><a href="#迭代化开发（增量）" class="headerlink" title="迭代化开发（增量）"></a>迭代化开发（增量）</h4><p>将描述、开发和验证等不同活动交织在 起，在开发过程中建立一系列版本，将系统一部分一部分地逐步交付。</p>
<h4 id="可转换模型"><a href="#可转换模型" class="headerlink" title="可转换模型"></a>可转换模型</h4><p>利用自动化的手段，通过一系列转换将需求规格化为一个可 交付使用的系统。</p>
<h2 id="用例建模"><a href="#用例建模" class="headerlink" title="用例建模"></a>用例建模</h2><p>用例是一种描述系统需求的方法，使用用例的方法来描述系统需求的过程就是用例建模。</p>
<p>1、基本思想：从用户的角度来看，他们并不想了解系统的内部结构和设计，他们所关心的是系统所能提供的服务，也就是被开发出来的系统将是如何被使用的。</p>
<p>2、用例模型的模型元素：</p>
<p>①参与者：参与者是指存在于被定义系统外部并与该系统发生交互的人或其他系统，他们代表的是系统的使用者或使用环境。</p>
<p>② 用 例：用例用于表示系统所提供的服务，它定义了系统是如何被参与者所使用的，它描述的是参与者为了使用系统所提供的某一完整功能而与系统之间发生的一段对话。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps86F9.tmp.jpg" alt="img"> </p>
<p>③通讯关联：通讯关联用于表示参与者和用例之间对应关系，它表示参与者使用了系统中的哪些服务（用例），或者说系统所提供的服务（用例）是被哪些参与者所使用的。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps86FA.tmp.jpg" alt="img"> </p>
<p>④系统边界：为了使得各个用例与子系统之间的关系更加明确，通常会使用一个系统边界来表</p>
<p>达一个子系统所包含的用例范围。</p>
<h3 id="3、两种表示形式"><a href="#3、两种表示形式" class="headerlink" title="3、两种表示形式"></a>3、两种表示形式</h3><p>①文本描述</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps870A.tmp.jpg" alt="img"> </p>
<p>②用例图</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps870B.tmp.jpg" alt="img"> </p>
<p>注：通讯关联表示的是参与者和用例之间的关系，箭头表示在这一关系，哪一方是对话的发主动发起者，箭头所指方是对话的被动接受者；如果你不想强调对话中的主动与被动关系，可以使用不带箭头的关联实线，在参与者和用例之间的信息流，不是由通讯关联来表示的，该信息流是缺省存在的（用例本身描述的就是参与者和系统之间的对话），并且信息流向是双向的，他与通讯关联箭头所指的方向毫无关系。</p>
<h3 id="4、用例建模过程"><a href="#4、用例建模过程" class="headerlink" title="4、用例建模过程"></a>4、用例建模过程</h3><p>用例模型主要包括：</p>
<p>①用例图——确定系统中所包含的参与者、用例和两者之间的对应关系，用例图描述的是关于系统功能的一个概述</p>
<p>②用例规约——针对每一个用例都应该有一个用例规约文档与之相对应，该文档描述用例的细节内容</p>
<p>（1）寻找参与者</p>
<p>参与者——所有存在于系统外部并与系统进行交互的人或其他系统</p>
<p>系统开发完成之后，有哪些人会使用这个系统？</p>
<p>系统需要从哪些人或其他系统中获得数据？</p>
<p>系统会为哪些人或其他系统提供数据？</p>
<p>系统会与哪些其他系统相关联？</p>
<p>系统是由谁来维护和管理的？</p>
<p>（2）识别用例</p>
<p>找到参与者之后，我们就可以根据参与者来确定系统的用例，主要是看各参与者需要系统提供什么样的服务，或者说参与者是如何使用系统的。</p>
<p>参与者为什么要使用该系统？</p>
<p>参与者是否会在系统中创建、修改、删除、访问、存储数据？如果是的话，参与者又是如何来完成这些操作的？</p>
<p>参与者是否会将外部的某些事件通知给该系统？</p>
<p>系统是否会将内部的某些事件通知该参与者？</p>
<p>（3）关联</p>
<p>在一般的用例图中，我们只表述参与者和用例之间的关系，即它们之间的通讯关联。除此之外，我们还可以描述参与者与参与者之间的泛化(generalization)、用例和用例之间的包含(include)、扩展(extend)和泛化(generalization)关系。我们利用这些关系来调整已有的用例模型，把一些公共的信息抽取出来重用，使得用例模型更易于维护。但是在应用中要小心选用这些关系，一般来说这些关系都会增加用例和关系的个数，从而增加用例模型的复杂度。而且一般都是在用例模型完成之后才对用例模型进行调整，所以在用例建模的初期不必要急于抽象用例之间的关系。</p>
<h2 id="面向对象分析及UML类图"><a href="#面向对象分析及UML类图" class="headerlink" title="面向对象分析及UML类图"></a>面向对象分析及UML类图</h2><h3 id="1、面向对象分析"><a href="#1、面向对象分析" class="headerlink" title="1、面向对象分析"></a>1、面向对象分析</h3><p>Ÿ 面向对象分析技术关注应用领域中的实体，并将其建模为对象</p>
<p>Ÿ 面向对象分析技术主要基于分类、泛华、聚合关系在对象集合之间建立结构</p>
<p>Ÿ 对象的行为是执行预定的动作（服务/活动）</p>
<p>Ÿ 对象通过执行动作来完成状态变迁</p>
<h3 id="2、面向对象分析的起源"><a href="#2、面向对象分析的起源" class="headerlink" title="2、面向对象分析的起源"></a>2、面向对象分析的起源</h3><p>Ÿ 面向对象程序设计（OPP）：将OPP中的概念上推到分析和设计阶段</p>
<p>Ÿ 数据库设计：将数据语义建模概念，如实体—关系、泛华、聚合和分类用于系统分析和设计</p>
<p>Ÿ 结构化分析：将结构化分析方法与技术，如SDAT方法等用于系统分析与建模</p>
<p>Ÿ 知识表示：采用基于问题框架和语义网络的知识表示方法</p>
<h3 id="3、面向对象分析方法举例"><a href="#3、面向对象分析方法举例" class="headerlink" title="3、面向对象分析方法举例"></a>3、面向对象分析方法举例</h3><p>Ÿ <img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB967.tmp.jpg" alt="img">Peter Coad的面向对象方法</p>
<p>Ÿ “对象”是问题领域中真实存在的实体，有“定义清晰的边界” </p>
<p>Ÿ 对象中封装有属性和行为</p>
<p>Ÿ 面向对象分析的五个核心概念：对象、属性、结构、服务和主题</p>
<h3 id="4、结构"><a href="#4、结构" class="headerlink" title="4、结构"></a>4、结构</h3><p>①结构/一般-特殊结构：一般-特殊结构将类组织成基于集成关系的分层次结构</p>
<p>Ÿ 自底向上是从特殊到一般的类</p>
<p>Ÿ 自顶向下是从一般到特殊的类</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB968.tmp.jpg" alt="img"> </p>
<p>②整体-部分结构</p>
<p>整体部分结构描述对象间的组合关系</p>
<p>一个交通灯对象由0-3个灯组，支撑杆和位置对象组合而成</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB969.tmp.jpg" alt="img"> </p>
<h3 id="5、服务"><a href="#5、服务" class="headerlink" title="5、服务"></a>5、服务</h3><p>①服务建模</p>
<p>对象为其周遭的其他对象提供服务，例如医生对象对外提供的服务包括体检、出体检报告等</p>
<p>Coad 的OAA方法中，定义了三中类型的服务：</p>
<p>Ÿ 瞬时服务：对象的创建、结束、修改等</p>
<p>Ÿ 计算服务：对象为其他对象完成计算服务等</p>
<p>Ÿ 监控服务：对象持续监控流程，检查预设条件是否满足</p>
<p>我们用带箭头的虚线来表示一个对象引用另一个对象的服务</p>
<p>注：从面向对象到面向服务，是看待问题的视角的切换</p>
<p>②服务关系</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB979.tmp.jpg" alt="img"> </p>
<h3 id="6、面向对象的分析方法学"><a href="#6、面向对象的分析方法学" class="headerlink" title="6、面向对象的分析方法学"></a>6、面向对象的分析方法学</h3><p>Ÿ 识别对象和类（类是对象的抽象定义）</p>
<p>Ÿ 识别类之间的关系，建立由继承和组合关系组成的类层次结构</p>
<p>Ÿ 定义主题，通过主题将对象模型组织成多个抽象层次或视角，一般来说通过继承关系或整体部分关系联系起来的类同属于一个主题</p>
<p>Ÿ 识别各个对象内部的属性信息，并将其赋予相应抽象层次的类</p>
<p>Ÿ 为每个类定义服务    </p>
<p>7、面向对象分析常用术语对照表</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB97A.tmp.jpg" alt="img"> </p>
<p>CRC卡片分拣法</p>
<p>1、识别类的方法</p>
<p>Ÿ 根据用例描述中的名词确定类的候选者</p>
<p>Ÿ 使用CRC卡分析法寻找类</p>
<p>Ÿ 根据边界类、控制类和实体类的划分来帮助发现系统中的类</p>
<p>Ÿ 对领域进行分析，或利用已有的领域分析结果得到类</p>
<p>Ÿ 参考分析、设计模式来确定类</p>
<p>2、CRC卡片</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB97B.tmp.jpg" alt="img"> </p>
<p>注：类对象通常对应一个命名实体，因此用名词表达</p>
<p>3、对象</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB97C.tmp.jpg" alt="img"> </p>
<p>4、类识别</p>
<p>Ÿ 从原始资料中识别类：找出干系人提交的问题描述中名词及短语（如果他描述应用领域中的信息结构或本质，则加入模型）</p>
<p>Ÿ 从其他来源识别：背景信息调查、用户及干系人提供、分析模式</p>
<p>Ÿ 最好识别处尽可能多的候选类：之后逐步按照其价值功用进行选择、明确判断后排除一个类要比不考虑来的合理</p>
<p>5、识别类的功能职责</p>
<p>功能职责关乎动作，因此是问题描述中的动词</p>
<p>注意：</p>
<p>1、并非所有动词均将成为类职责</p>
<p>2、有时多个动作合并为一个职责</p>
<p>3、随着分析过程深入会发现新的职责</p>
<p>4、不断修正类定义和职责定义</p>
<p>5、当两个类分享职责时，为二者同时添加该职责</p>
<p>4、类筛选</p>
<p>Ÿ 在候选类中排除一下类：</p>
<p>超出问题关注的范围的类</p>
<p>指代整个系统的类</p>
<p>功能重复的类</p>
<p>过于含糊或过于具体的类</p>
<p>可观察到的现象是，实例对象过多或过少</p>
<p>Ÿ Coad &amp;Yourdon’s的筛选原则：</p>
<p>保存对象信息：系统需要保存对象信息吗？</p>
<p>提供所需服务：类对象是否对外提供修改属性值的操作？</p>
<p>具有多个属性：只有一个属性的类，应该建模为属性</p>
<p>具有公共属性：类属性是否为所有实例对象共享？</p>
<p>具有公共操作：类操作是否为所有实例对象共享？</p>
<p>外部实体：如果生产或使用对象的信息，也应考虑建模为系统类</p>
<p>类图建模</p>
<p>1、什么是类</p>
<p>具有相同性质、相同行为、相同的对象关系、相同语义的对象的集合</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB97D.tmp.jpg" alt="img"> </p>
<p>2、对象</p>
<p>Ÿ 对象是类的实例</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB98E.tmp.jpg" alt="img"> </p>
<p>注：两个不同的对象可以有相同的属性取值</p>
<p>Ÿ 对象与其他对象之间发生关联关系</p>
<p>Ÿ 注意将属性划归正确的类</p>
<p>3、类属性定义</p>
<p>属性在类图标的属性分隔框中用文字串说明，UML规定属性的语法为：</p>
<p>[可见性]属性名[：类型]{[多样性[次序]]}[=c初始值][{约束}]</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB98F.tmp.jpg" alt="img"><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB990.tmp.jpg" alt="img"> </p>
<p>4、类关系</p>
<p>Ÿ 对象并非遗世独立，对象间存在千丝万缕的联系</p>
<p>UML中，关注一下几种类型的关系：</p>
<p>Ÿ 关联关系：聚合与组合关系</p>
<p>Ÿ 泛华关系</p>
<p>Ÿ 依赖关系</p>
<p>Ÿ 实现关系</p>
<p>Ÿ 类图描述类和他们之间的关系</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB991.tmp.jpg" alt="img"> </p>
<p>5、关联关系的种类</p>
<p>按照关联所连接的类的数量，对象类之间的关联可分为：自反关联、二元关联，N元关联</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB992.tmp.jpg" alt="img"> </p>
<p>关联关系图例</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB993.tmp.jpg" alt="img"> </p>
<p>6、关联类</p>
<p>有时要为关联相关信息的存储定义一个专门的类，称为“关联类”</p>
<p>保存与关联关系本身相关的信息</p>
<p>这些信息不属于关联所连接的两端的类</p>
<p>例：“title”类的对象中存储的是车主和车辆之间所属关系有关的信息</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9A4.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9A5.tmp.jpg" alt="img">7、限定关联</p>
<p>在关联端紧靠源类图标处可以有限定符。带有限定符的关联称为限定关联。</p>
<p>Ÿ 限定符是关联的属性</p>
<p>Ÿ 限定符的作用是，给定关联一段的一个对象和限定符值，可确定另一端的一个对象或对象集</p>
<p>8、聚合与组合关系</p>
<p>Ÿ 聚合用于表达一个整体对象与其他成员对象之间的关系</p>
<p>Ÿ 组合用于表达一个整体对象与其组成部分之间的关系</p>
<p>Ÿ 组合关系所表达的整体类与部分类之间的所属关系更强</p>
<p>整体类的对象不存在时，部分类的对象也不存在</p>
<p>整体类对象撤销之前要复杂将部分类对象撤销</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9A6.tmp.jpg" alt="img"> </p>
<p>9、继承/泛华</p>
<p>Ÿ 子类继承父类的属性、关联和操作</p>
<p>Ÿ 子类可以覆盖继承的内容</p>
<p>Ÿ 父类可以声明为抽象类，则将不会为它直接创建实例对象</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9A7.tmp.jpg" alt="img"> </p>
<p>Ÿ 继承/泛华关系建模的意义在于系统环境发生变化时便于添加新的子类</p>
<p>Ÿ 继承/泛华关系建模的过程</p>
<p>自顶向下——将某个类分割为属性和操作不同的子类，或者发现关联关系定义的是分类关系</p>
<p>自底向上——为现有的多个具有公共属性及方法的类，定义一个父类</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9A8.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9A9.tmp.jpg" alt="img"> <img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9B9.tmp.jpg" alt="img"></p>
<p>10、类图的抽象</p>
<p>在软件开发的不同阶段使用的类图具有不同的抽象层次。概念类、设计说明类和实现类。最先由Steve Cook和John Daniels引入。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9BA.tmp.jpg" alt="img"> </p>
<p>11、类图建模风格</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsB9BB.tmp.jpg" alt="img"> </p>
<h2 id="软件系统设计"><a href="#软件系统设计" class="headerlink" title="软件系统设计"></a>软件系统设计</h2><h3 id="1软件体系结构概念"><a href="#1软件体系结构概念" class="headerlink" title="1软件体系结构概念"></a>1软件体系结构概念</h3><p>1.1概念</p>
<p>软件体系结构包括构成系统的设计元素的描述、设计元素之间的交互、设计元素的组合模式以及这这些模式中的约束。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps261D.tmp.jpg" alt="img"> </p>
<p>1.2目标</p>
<p>ž 如何将复杂的软件系统划分成模块</p>
<p>ž 如何规范模块的构成</p>
<p>ž 如何将这些模块组织成为完整的系统</p>
<p>ž 如何保证系统的质量要求</p>
<p>注：当系统的规模和复杂度不断增大的时候，构造整个系统的关键是对整个系统的结构和行为进行抽象。</p>
<h3 id="2-软件体系结构-构件-连接件-约束"><a href="#2-软件体系结构-构件-连接件-约束" class="headerlink" title="2.软件体系结构=构件+连接件+约束"></a>2.<strong>软件体系结构=构件+连接件+约束</strong></h3><p>2.1构件</p>
<p>构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素和数据存储</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps261E.tmp.jpg" alt="img"> </p>
<p>①构件组合成系统</p>
<p>②构件提供服务，通过结构与其他构件进行交互</p>
<p>2.2连接件</p>
<p>连接件是负责构件之间交互的专用构件，如管道</p>
<p>构件是软件功能设计和实现的承载体</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps261F.tmp.jpg" alt="img"> </p>
<p>连接机制：过程调用、中断、I/O、事件、进程、线程、共享、同步、并发、消息、远程调用、动态连接、API等等</p>
<p>连接协议： 对过程调用来说——参数的个数和类型、参数排列次序</p>
<p>​      对消息传送来说——消息的格式</p>
<h3 id="3-软件体系结构的目标"><a href="#3-软件体系结构的目标" class="headerlink" title="3.软件体系结构的目标"></a>3.软件体系结构的目标</h3><p>可重用性、可扩展性、可改变性、简单性、有效性</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2620.tmp.jpg" alt="img"> </p>
<p>4.软件体系结构的发展</p>
<p>面向过程的分析与设计——面向对象的分析与设计——基于构件的软件开发——面向服务的计算、面向服务的体系结构</p>
<p>设计的趋势：分布式、低耦合、开放</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2621.tmp.jpg" alt="img"> </p>
<p>5.风格、模式和框架</p>
<p>主程序 - 子程序，树形结构，如C程序</p>
<p>面向对象，网状结构，如CPP/JAVA程序</p>
<p>管道 - 过滤器，通过输入和输出串联，线性结构，如媒体播放器</p>
<p>仓库结构，以数据为中心，放射状结构，如剪贴板、编译器、数据库</p>
<p>层次结构</p>
<p>客户机 - 服务器</p>
<p>表示层 -（功能层）- 数据层</p>
<p>MVC结构：Model 模型、视图 View、控制器 Controller，前端给后端AJAX，后端返回给前端JSON</p>
<p>REST，RE presentational State Transfer</p>
<p>事件风格，以代码调试为例</p>
<p>调试器设置断点，作为事件源</p>
<p>IDE作为事件管理器，事件触发时发出消息</p>
<p>文本编辑器、编译器、变量监视器对断点事件进行响应，相当于event handler</p>
<p>具体实现分为发布订阅模式和观察者模式</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2622.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2623.tmp.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2624.tmp.jpg" alt="img"> </p>
<p>6.软件设计原则</p>
<p>6.1抽象——关注事物中与问题相关部分而忽略其他无关部分的一种思考方法</p>
<p>6.2封装和信息隐藏——每个软件单元对其他所有单元都隐藏自己的设计决策，各个单元的特性通过其外部可见的接口来描述</p>
<p>要求：应将单元接口设计得尽可能简单，并将单元对于环境的假设和要求降至最低</p>
<p>6.3模块化——在逻辑和物理上将整个系统分解成多个更小的部分，其实质是“分而治之”，即将一个复杂问题分解成若干个简单问题，然后逐个解决</p>
<p>系统分解的目标：高内聚、低耦合</p>
<p>内聚性是一个模块或子系统内部的依赖程度</p>
<p>耦合性是两个模块或子系统之间依赖关系的强度</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2635.tmp.jpg" alt="img"> <img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2636.tmp.jpg" alt="img"></p>
<p>6.4层次化——</p>
<p>分层：  每一层可以访问下层，不能访问上层；分层机构：每一层只能访问与其相邻的下一层；开放式结构：每一层还可以访问下面更低的层次；层次数目不应超过7±2层</p>
<p>划分：系统被分解成互相对等的若干模块单元；每个模块之间依赖较少，可以独立运行</p>
<p>注：模块单元增加了处理开销，过度分层或划分会增加复杂性</p>
<p>6.5复用——利用某些已开发的、对建立新系统有用的软件元素来生成新的软件系统，其好处在于提高生产效率，提高软件质量 </p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2637.tmp.jpg" alt="img"> </p>
<p>7.客户机/服务器结构</p>
<p>客户机/服务器体系结构是一种分布式系统模型，作为服务器的子系统为其他客户机的子系统提供服务，作为客户机的子系统负责与用户的交互</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2638.tmp.jpg" alt="img"> </p>
<p>7.1两层C/S结构（胖客户端模型）</p>
<p>业务逻辑的划分比重：</p>
<p>胖客户端：客户端执行大部分的数据处理操作</p>
<p>瘦客户端：客户端具有很少或没有业务逻辑</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps2639.tmp.jpg" alt="img"> </p>
<p>7.2三层C/S结构 </p>
<p>表示层：包括所有与客户机交互的边界对象，如窗口、表单、网页等</p>
<p>功能层：包括所有的控制和实体对象，实现应用程序的处理逻辑和规则</p>
<p>数据层：实现对数据库的存储、查询和更新</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps263A.tmp.jpg" alt="img"> </p>
<p>7.3B/S结构</p>
<p>浏览器/服务器结构是三层C/S风格的一种实现方式</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps263B.tmp.jpg" alt="img"> </p>
<p>8.Web系统架构设计</p>
<p>9.数据库选择策略</p>
<p>l 关系型，规整的表格；key-value型，灵活的内容</p>
<p>l 事务，即对数据库的一次操作确保原子性，完全执行或不执行</p>
<p>l 一致性，A发照片，好友都能看到；理想情况要求实时，现实中允许一定延迟</p>
<p>l 主要的数据库类型：</p>
<p>n MySQL，关系型数据库，支持事务操作，安全性高</p>
<p>n MongoDB，非关系型数据库，结构灵活，数据模型易扩展易修改，分布式，不支持事务操作，安全性一般</p>
<p>n Redis，内存数据库，速度快，数据安全性差</p>
<p>l 需要事务操作 - MySQL，发展中的业务 - MongoDB，频繁读取 - Redis</p>
<h2 id="UML活动图及其建模"><a href="#UML活动图及其建模" class="headerlink" title="UML活动图及其建模"></a>UML活动图及其建模</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>一个UML活动图表示一个过程中的多个顺序活动和并行活动。这些活动图有助于对业务过程、工作流、数据流和复杂算法进行建模。</p>
<h3 id="2、活动图基本元素"><a href="#2、活动图基本元素" class="headerlink" title="2、活动图基本元素"></a>2、活动图基本元素</h3><p><strong>初始节点和活动终点</strong></p>
<p>用一个实心圆表示初始节点</p>
<p>用一个圆圈加一个实心圆表示活动终点</p>
<p><strong>活动节点</strong></p>
<p>矩形（四角圆弧）</p>
<p><strong>转换</strong></p>
<p>当一个活动结束时，控制流就会马上传递给下一个活动节点，在活动图中称之为“转换”，用一条带箭头的直线来表示</p>
<p><strong>分支与监护条件</strong></p>
<p>分支用菱形表示，他有一个进入转换（箭头从外指向内分支符号），一个或多个离开转换（箭头从分支符号指向外）。而每个离开转换上都会有一个监护条件，用来表示满足什么条件的时候执行该转换</p>
<p><strong>分岔与汇合</strong></p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsF58A.tmp.jpg" alt="img"> </p>
<p><strong>泳道</strong></p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wpsF58B.tmp.jpg" alt="img"> </p>
<p>3、准则</p>
<p>ž 活动图通常对于设计众多参与者的非常复杂的业务过程，建模具有价值。对于简单的业务过程，用例文本就足够用了。</p>
<p>ž 在进行业务过程建模时，可以利用耙字符号和子活动图。</p>
<p>ž 与上一条相关的是，尽量保持同一张图中所有动作几点的抽象水平一致。</p>
<p>UML状态机图及其建模</p>
<p>1、简介</p>
<p>UML状态机图描述了某个对象的状态和感兴趣的时间以及对象响应该事件的行为。</p>
<p>通常我们创建一个UML状态图是为了以下的研究目的：研究类、角色、子系统、或组件的复杂行为。</p>
<p>2、状态机图基本元素</p>
<p><strong>状态</strong></p>
<p>状态指的是对象在其生命周期中的一种状况，处于某个特定状态中的对象必然会满足某些条件、执行某些动作或者是等待某些事件。一个状态的生命周期是一个有限的时间阶段。</p>
<p><strong>转换</strong></p>
<p>转换指的是两个不同状态之间的一种关系，表明对象在第一个状态中执行一定的动作，并且在满足某个特定条件下由某个事件触发进入第二个状态。</p>
<p><strong>事件</strong></p>
<p>事件指的是发生在时间和空间上的对状态机来讲有意义的那些事情。事件通常会引起状态的变迁，促使状态机从一种状态切换到另一种状态，如信号、对象额度创建和销毁等。</p>
<p><strong>活动</strong></p>
<p>活动指的是状态机中进行的非原子操作。</p>
<p><strong>动作</strong></p>
<p>动作指的是状态机中可以执行的哪些原子操作。所谓原子操作，指的是他们在运行的过程中不能被其他消息中断，必须一直执行下去，以至最终导致状态的变更或者返回一个值。</p>
<h2 id="详细设计及结构化程序"><a href="#详细设计及结构化程序" class="headerlink" title="详细设计及结构化程序"></a>详细设计及结构化程序</h2><h3 id="1、详细设计阶段——根本目标：确定应该怎样具体实现所需求的系统"><a href="#1、详细设计阶段——根本目标：确定应该怎样具体实现所需求的系统" class="headerlink" title="1、详细设计阶段——根本目标：确定应该怎样具体实现所需求的系统"></a>1、详细设计阶段——根本目标：确定应该怎样具体实现所需求的系统</h3><h3 id="2、结构化程序设计的经典定义"><a href="#2、结构化程序设计的经典定义" class="headerlink" title="2、结构化程序设计的经典定义"></a>2、结构化程序设计的经典定义</h3><p>如果一个程序的代码块仅仅通过顺序、选择和循环这三种控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的</p>
<h3 id="3、三种基本的控制结构"><a href="#3、三种基本的控制结构" class="headerlink" title="3、三种基本的控制结构"></a>3、三种基本的控制结构</h3><p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps705B.tmp.jpg" alt="img"> </p>
<p>4、结构化程序设计的主要原则</p>
<p>Ÿ 使用语言中的顺序、选择、重复等有限的基本控制结构表示程序逻辑</p>
<p>Ÿ 复杂结构应该用基本控制结构进行组合嵌套来实现</p>
<p>Ÿ 选用的控制结构只准许有一个入口和一个出口</p>
<p>Ÿ 严格控制GOTO语句，仅在下列情形才可使用：</p>
<p>1、若不使用GOTO语句就会使程序功能模糊</p>
<p>2、在某种可以改善而不是损害程序可读性的情况下。</p>
<p>5、程序流程图</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps705C.tmp.jpg" alt="img"><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps705D.tmp.jpg" alt="img"> </p>
<p>缺点：过早注重细节、过于详细、随意转换控制、不易表示数据结构</p>
<p>6、盒图</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps705E.tmp.jpg" alt="img"> </p>
<p>特点</p>
<p>Ÿ 功能域明确</p>
<p>Ÿ 不能任意转换控制</p>
<p>Ÿ 容易确定变量的作用域</p>
<p>Ÿ 容易表现嵌套关系及模块的层次结构</p>
<p>7、判定表</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps705F.tmp.jpg" alt="img"> </p>
<p>特点</p>
<p>Ÿ 能够简洁无歧义地描述复杂处理规则</p>
<p>Ÿ 可以校验和化简</p>
<p>Ÿ 无法通程序结构直接关联</p>
<p>8、判定树</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps7060.tmp.jpg" alt="img"> </p>
<p>9、程序设计语言</p>
<p>Ÿ PDL也称为伪码，它是用正文形式表示数据和处理过程的设计工具</p>
<p>Ÿ PDL具有严格的关键字外部语法，用于定义控制结构和数据结构</p>
<p>Ÿ PDL是一种“混杂”语言，它使用一种语言（通常是某种自然语言）的词汇，同时却使用另一种语言的语法（某种结构化的程序设计语言）</p>
<p>PDL特点</p>
<p>Ÿ 容易与程序注释结合，容易编辑</p>
<p>Ÿ 可以定义数据结构</p>
<p>Ÿ 机器可以识别，能自动生产程序框架</p>
<p>Ÿ 缺乏直观性</p>
<h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><h3 id="1、测试用例"><a href="#1、测试用例" class="headerlink" title="1、测试用例"></a>1、测试用例</h3><p>测试数据和预期的输出结果称为测试用例</p>
<p>Ÿ 具体的测试目的（例如，要测试的具体功能）</p>
<p>Ÿ 应该输入的测试数据</p>
<p>Ÿ 预期的输出结果</p>
<h3 id="2、黑盒测试和白盒测试"><a href="#2、黑盒测试和白盒测试" class="headerlink" title="2、黑盒测试和白盒测试"></a>2、黑盒测试和白盒测试</h3><p>Ÿ 黑盒测试法把程序看成一个黑盒子，完全不考虑程序的内部结构和处理过程，黑盒测试又称为<strong>功能测试</strong></p>
<p>Ÿ 白盒测试法的前提是可以把程序看成装在一个透明的白盒子里，也就是完全了解程序的结构和处理过程，白盒测试又称为<strong>结构测试</strong></p>
<h3 id="3、相关概念"><a href="#3、相关概念" class="headerlink" title="3、相关概念"></a>3、相关概念</h3><p>逻辑覆盖：</p>
<p>逻辑覆盖是设计白盒测试方案的一种技术；这组测试过程逐渐进行越来越完成的通路测试；选用少量“最有效的”测试数据；尽可能完备的测试</p>
<p>语句覆盖：</p>
<p>选择足够多的测试数据，使被测程序中每个语句至少执行一次</p>
<p>判定覆盖（分支覆盖）：</p>
<p>不仅每个语句必须至少执行一次；而且每各判定的每种可能的结果都应该至少执行一次，也就是每个判定的每个分支都至少执行一次</p>
<p>其他逻辑覆盖</p>
<p>条件覆盖：不仅每个语句至少执行一次，而且使判定表达式中的每个条件都去到各种可能的结果</p>
<p>判定/条件覆盖：选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</p>
<h3 id="4、McCabe方法——流图"><a href="#4、McCabe方法——流图" class="headerlink" title="4、McCabe方法——流图"></a>4、McCabe方法——流图</h3><p>McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，度量出的结果称为程序的<strong>环形复杂程度</strong></p>
<p>为了突出表示程序的控制流，人们通常使用<strong>流图</strong>（也称为程序图）</p>
<p>实质——“退化了的”程序流程图</p>
<p>Ÿ 仅仅描绘程序的控制流程</p>
<p>Ÿ 不表现对数据的具体操作</p>
<p>Ÿ 不表现分支或循环的具体条件</p>
<h3 id="5、流图"><a href="#5、流图" class="headerlink" title="5、流图"></a>5、流图</h3><p><strong>节点：</strong></p>
<p>在流图中用圆表示，一个圆代表一条或多条无分支语句</p>
<p><strong>边：</strong></p>
<p>流图中的箭头线，和程序流程图中的箭头线类似，代表控制流</p>
<p>在流图中一条边必须终止于一个节点，即使这个节点并不代表认识语句（实际上相当于一个空语句）</p>
<p><strong>区域：</strong></p>
<p>由边和节点围成的面积，当计算区域数时应该包括图外部未被包围起来的那个区域</p>
<h3 id="6、环形复杂度"><a href="#6、环形复杂度" class="headerlink" title="6、环形复杂度"></a>6、环形复杂度</h3><p>环形复杂度定量度量程序的逻辑复杂性</p>
<p>Ÿ V(G)=E-N+2，其中E是流图中边的条数，N是流图中节点数。</p>
<p>Ÿ V(G)=P+1，其中P是流图中判定节点的数目。</p>
<h3 id="7、基本路径测试"><a href="#7、基本路径测试" class="headerlink" title="7、基本路径测试"></a>7、基本路径测试</h3><p>概念</p>
<p>以流图的环形复杂度为指南定义执行路径的基本集合，从该基本集合导出的测试用例可以保证程序中的每条语句至少执行一次，而且每个条件在执行时都将分别取true和false值。</p>
<p>步骤</p>
<p>①根据过程设计结果画出相应的流图</p>
<p>②计算流图的环形复杂度</p>
<p>③确定线性独立路径的基本集合</p>
<p>a、程序的环形复杂度决定了程序中独立路径的数量</p>
<p>b、独立路径至少包含一条在定义该路径之前不曾用过的边</p>
<p>④设计可强制执行基本集合中每条路径的测试用例</p>
<p>黑盒测试</p>
<p>1测试</p>
<p>1.1测试用例的重要性——设计良好的测试用例是关键</p>
<p>①降低软件测试成本</p>
<p>②保证测试工作质量</p>
<p>③评估和检验测试效果</p>
<p>1.2测试用例的概念</p>
<p>Ÿ 测试用例值：完成被测软件的某个执行所需的输入值</p>
<p>Ÿ 期望结果：当且仅当程序满足其期望行为，执行测试时产生的结果</p>
<p>Ÿ 前缀值：将软件置于合适的状态来接受测试用例值的任何必要的输入</p>
<p>Ÿ 后缀值：测试用例值被发送以后，需要被发送到软件的任何输入</p>
<p>测试集——测试用例值的集合</p>
<p>验证值——查看测试用例值结果所要用到的值</p>
<p>结束命令——终止程序或返回到稳定状态所要用到的值</p>
<p>Eg.</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD3.tmp.jpg" alt="img"> </p>
<p>1.3测试用例设计的要求</p>
<p>①具有代表性和典型性</p>
<p>②寻求系统设计和功能设计的弱点</p>
<p>③既有正确输入也有错误或异常输入</p>
<p>④考虑用户交际的诸多场景</p>
<h2 id="黑盒测试技术"><a href="#黑盒测试技术" class="headerlink" title="黑盒测试技术"></a>黑盒测试技术</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>黑盒测试时将测试对象看作一个黑盒子，完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD4.tmp.jpg" alt="img"> </p>
<h3 id="2-2等价类划分"><a href="#2-2等价类划分" class="headerlink" title="2.2等价类划分"></a>2.2等价类划分</h3><p>2.2.1概念</p>
<p>等价类划分是将输入域划分成尽可能少的若干子域，在划分中要求每个子域两两互不相交，每个子域称为一个等价类。</p>
<p>注：同一输入域的等价类划分可能不唯一；只需从每一个等价类中选取一个输入作为测试用例；对于相同的等价类划分，不同测试人员选取的测试用例集可能是不同的</p>
<p>2.2.2等价类类型</p>
<p>Ÿ <strong>有效等价类</strong>是对规格说明有意义、合理的输入数据构成的集合，能够检验程序是否实现了规格说明中预先规定的功能和性能。</p>
<p>Ÿ <strong>无效等价类</strong>是对规格说明无意义、不合理的输入数据构成的集合，以检查程序是否具有一定的容错性。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD5.tmp.jpg" alt="img"> </p>
<p>2.2.3变量的等价类</p>
<p><strong>取值范围</strong>：在输入条件规定了取值范围的情况下，可以确定一个有效等价类和两个无效等价类。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD6.tmp.jpg" alt="img"> </p>
<p><strong>字符串</strong>：在规定了输入数据必须遵守的规则情况下，可确定一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD7.tmp.jpg" alt="img"> </p>
<p><strong>枚举</strong>：若规定输入数据是一组值（假定N个），并且程序要对每一个输入值分别处理，可确定N个有效等价类和一个无效等价类</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD8.tmp.jpg" alt="img"> </p>
<p><strong>数组</strong>：数组是一组具有相同类型的元素的集合，数组长度及其类型都可以作为等价类划分的依据。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CD9.tmp.jpg" alt="img"> </p>
<p><strong>复合数据类型</strong>：符合数据类型是包含两个或两个以上相互独立的属性的输入数据，在进行等价类划分时需要考虑输入数据的每个属性的合法和非法属性。</p>
<p><img src="file:///C:\Users\LUSIR~1\AppData\Local\Temp\ksohtml\wps9CDA.tmp.jpg" alt="img"> </p>
<p><strong>测试用例生成</strong>：测试对象通常有多个输入参数，如何对这些参数等价类进行组合测试，来保证等价类的覆盖率，是测试用例设计首先需要考虑的问题。</p>
<p>Ÿ 所有有效等价类的代表值都集成到测试用例中，即覆盖有效等价类的所有组合。任何一个组合都将设计成一个有效的测试用例，也称<strong>正面测试用例</strong>。</p>
<p>Ÿ 无效等价类的代表值只能和其他有效等价类的代表值（随意）进行组合。因此，每个无效等价类都将产生一个额外的无效测试用例，也称<strong>负面测试用例</strong>。</p>
<h3 id="2-3边界值分析"><a href="#2-3边界值分析" class="headerlink" title="2.3边界值分析"></a>2.3边界值分析</h3><p>2.3.1概念</p>
<p><strong>边界值分析</strong>是对输入或输出的边界值进行测试的一种方法，它通常作为等价类划分的补充，这种情况下的测试用例来自等价类的边界</p>
<p>Ÿ 先确定边界：通常输入或输出等价类的边界就是应该着重测试的边界情况</p>
<p>Ÿ 选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值</p>
<p>实践表明：大多数故障往往发生在输入定义域或输出值域的边界上，而不是内部。因此，针对各种边界情况测试用例，通常会取得很好的测试效果。</p>
<p>2.3.2基本思想</p>
<p>故障往往出现在程序输入变量的边界值附近</p>
<p>边界值分析法是基于可靠性理论中称为<strong>“单故障”</strong>的假设，即有两个或两个以上故障同时出现而导致失效的情况很少。</p>
<p>对程序中的每个变量重复：每次保留一个变量，让其余的变量取正常值，被保留的变量依次取min、min+、nom、max-和max+。</p>
<p>3健壮性测试</p>
<p><strong>健壮性测试</strong>是作为边界值分析的一个简单的扩充，它除了对变量的5个边界值分析取指外，还要增加一个略大于最大值（max+）以及略小于最小值（min-）的取值，检查超过极限值时系统的情况。</p>
<p>4错误推测法</p>
<p><strong>错误推测法</strong>是人们根据经验或直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例的方法。</p>
<p>Ÿ 软件缺陷具有空间聚集性，80%的缺陷常常存在于20%的代码中。因此，应当记住常常光临代码的高危多发“地段”，这样发现缺陷的可能性会大得多。</p>
<p>Ÿ 列举程序中所有可能的错误和容易发生错误的特殊情况，根据可能出现的错误情况选择测试用例。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:2914475618@qq.com">Lu sir</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://a2914475618.github.io/2021/09/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">https://a2914475618.github.io/2021/09/29/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://a2914475618.github.io" target="_blank">一位可可爱爱的编橙爱好者</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/v2-987f388663dab9d9c63105c2d82645e0_720w.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/10/01/shiro/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/EIB45)%5D~89GY%7D46@F$RAGMC.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">shiro</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/27/Mybatis/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/M2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mybatis</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/Touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Lu sir</div><div class="author-info__description">如风的少年</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/a2914475618"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到爱的小屋，爱你们哟</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">软件工程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%AC%E8%B4%A8%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.本质特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.面临的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.基本要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.软件开发基本策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">软件开发过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">过程方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">软件过程分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B-1"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">软件开发过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">瀑布模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">原始化模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E5%A2%9E%E9%87%8F%EF%BC%89"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">迭代化开发（增量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">可转换模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.3.</span> <span class="toc-text">用例建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%A4%E7%A7%8D%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">3、两种表示形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">4、用例建模过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E5%8F%8AUML%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">面向对象分析及UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、面向对象分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、面向对象分析的起源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、面向对象分析方法举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="toc-number">1.4.6.</span> <span class="toc-text">6、面向对象的分析方法学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.5.</span> <span class="toc-text">软件系统设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1软件体系结构概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-%E6%9E%84%E4%BB%B6-%E8%BF%9E%E6%8E%A5%E4%BB%B6-%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.软件体系结构&#x3D;构件+连接件+约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.软件体系结构的目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.6.</span> <span class="toc-text">UML活动图及其建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">2、活动图基本元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E5%8F%8A%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">详细设计及结构化程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E9%98%B6%E6%AE%B5%E2%80%94%E2%80%94%E6%A0%B9%E6%9C%AC%E7%9B%AE%E6%A0%87%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%BA%94%E8%AF%A5%E6%80%8E%E6%A0%B7%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%89%80%E9%9C%80%E6%B1%82%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">1、详细设计阶段——根本目标：确定应该怎样具体实现所需求的系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BB%8F%E5%85%B8%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">2、结构化程序设计的经典定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">3、三种基本的控制结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.</span> <span class="toc-text">白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">1、测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E5%92%8C%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">2、黑盒测试和白盒测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.3.</span> <span class="toc-text">3、相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81McCabe%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E6%B5%81%E5%9B%BE"><span class="toc-number">1.8.4.</span> <span class="toc-text">4、McCabe方法——流图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%B5%81%E5%9B%BE"><span class="toc-number">1.8.5.</span> <span class="toc-text">5、流图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%8E%AF%E5%BD%A2%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.8.6.</span> <span class="toc-text">6、环形复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.7.</span> <span class="toc-text">7、基本路径测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">1.9.</span> <span class="toc-text">黑盒测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">2.1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86"><span class="toc-number">1.9.2.</span> <span class="toc-text">2.2等价类划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">1.9.3.</span> <span class="toc-text">2.3边界值分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/10/Java%E5%B9%B6%E5%8F%91/" title="Java并发"><img src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发"/></a><div class="content"><a class="title" href="/2022/03/10/Java%E5%B9%B6%E5%8F%91/" title="Java并发">Java并发</a><time datetime="2022-03-10T04:33:25.000Z" title="发表于 2022-03-10 12:33:25">2022-03-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/07/Java%E5%AE%B9%E5%99%A8/" title="Java容器"><img src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java容器"/></a><div class="content"><a class="title" href="/2022/03/07/Java%E5%AE%B9%E5%99%A8/" title="Java容器">Java容器</a><time datetime="2022-03-07T11:22:26.000Z" title="发表于 2022-03-07 19:22:26">2022-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/07/Java%E9%9D%A2%E7%BB%8F-0/" title="Java核心知识"><img src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java核心知识"/></a><div class="content"><a class="title" href="/2022/03/07/Java%E9%9D%A2%E7%BB%8F-0/" title="Java核心知识">Java核心知识</a><time datetime="2022-03-07T03:08:27.000Z" title="发表于 2022-03-07 11:08:27">2022-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/06/Kafka%E9%9D%A2%E7%BB%8F/" title="Kafka面经"><img src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kafka面经"/></a><div class="content"><a class="title" href="/2022/03/06/Kafka%E9%9D%A2%E7%BB%8F/" title="Kafka面经">Kafka面经</a><time datetime="2022-03-06T10:42:57.000Z" title="发表于 2022-03-06 18:42:57">2022-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/" title="操作系统面经"><img src="https://cdn.jsdelivr.net/gh/a2914475618/github-jsdelivr-@main/img/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统面经"/></a><div class="content"><a class="title" href="/2022/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/" title="操作系统面经">操作系统面经</a><time datetime="2022-03-05T06:30:03.000Z" title="发表于 2022-03-05 14:30:03">2022-03-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Lu sir</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我的肩上是风，风上是闪烁的星群</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'pc3JDCREMGoF3S3e4YzeC6kX-gzGzoHsz',
      appKey: '01uhcP5vYPOKkVzxt5chIypp',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="js/jquery.min.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>